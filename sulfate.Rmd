---
title: "`r basename(getwd())`"
author: "Becky Alexander, Andy Schauer, Ursula Jongebloed, Drew Pronovost, Alli Moon, ..."
date: "prepared on `r Sys.Date()`"
output:
  html_document:
    keep_md: true
    df_print: paged
    number_sections: false
    toc: false
---

```{css Style, echo=FALSE}
h1.title {font-size: 16px; text-align: right}
h4.author {font-size: 12px; text-align: right}
h4.date {font-size: 12px; text-align: right}

div.main-container {
  max-width: 1200px !important;
  margin-left: auto;
  margin-right: auto;
  padding-left: 20px;   /* optional: add some breathing room */
  padding-right: 20px;
}

.clearboth{clear:both}
.thumbnail{float:left}
.list{float:left; width:30rem}
.main_list_figures{float:right}
.section-indent{margin-left:2rem}
.expandable_subtitles{font-size: 24px; color: blue; text-decoration: underline}
.high_res_sample{font-size: 12px}

table{
  width: auto !important;
  border-collapse: collapse;
	margin:0.5rem;
	padding:0.5rem;
}

table tr:hover {
	background-color: #ffff99;
}

table caption{
	text-align:left;
	margin-bottom:1rem;
}

table th{
	border-bottom:1px solid black;
}

table td{
	text-align:center;
	padding:1.0rem;
	padding-right:2.0rem;
}

```

```{r Libraries, echo=FALSE, include=FALSE}
library(bslib)
library(cowplot)
library(dplyr)
library(fs)
library(furrr)
library(future)
library(ggplot2)
library(glue)
library(grid)
library(gridExtra)
library(htmltools)
library(isoorbi)
library(jsonlite)
library(kableExtra)
library(plotly)
library(progressr)
library(purrr)
library(ragg)
library(stringr)
library(tibble)
library(tidyr)
library(viridis)
library(zoo)
```

```{r Initialization, echo=FALSE, include=FALSE}
# -------------------- THINGS YOU MAY WANT TO CHANGE RUN-TO-RUN --------------------

wM0_SAMPLES_TO_IGNORE <- c()          # if a particular sample is bad, enter its filename with quotes around it here, e.g. 'SodSul-2-ref_5'
noM0_SAMPLES_TO_IGNORE <- c()

ABS_DELTA_T_THRESHOLD <- 0.1      # Set threshold of sample vs standard temperature difference for flagging data

d17O_CALIBRATION_STANDARDS <- c('SodSul_6', 'S_delta') 
d18O_CALIBRATION_STANDARDS <- c('SodSul_6', 'S_delta')
d33S_CALIBRATION_STANDARDS <- c('SodSul_8', 'S_MIF_2')
d34S_CALIBRATION_STANDARDS <- c('SodSul_8', 'S_MIF_2')

PEAK_DEFINITION_STRATEGY <- 'combined'                   # options are:  'smoothed_derivative', 'trimmed_median', 'combined', 'manual'
SAMPLE_PEAK_START <- 1.0
SAMPLE_PEAK_END <-4.0

run_this <- FALSE
```



```{r Functions, echo=FALSE, include=FALSE}

extract_conc <- function(x) {
  # TRUE for names that *end* in something like "15uM" or "22p5uM"
  has_conc <- grepl("[0-9]+(?:p[0-9]+)?uM$", x)

  # Pull out just the numeric (and p) part after the last underscore:
  # "SodSul_4_17p5uM" -> "17p5"
  conc_str <- ifelse(
    has_conc,
    sub(".*_([0-9]+(?:p[0-9]+)?)uM$", "\\1", x),
    NA_character_
  )

  # Turn "17p5" into "17.5"
  conc_str <- sub("p", ".", conc_str)

  # Final numeric vector
  as.numeric(conc_str)
}


ideal_text_color <- function(hex) {
  # Convert "#RRGGBB" → numeric RGB
  rgb <- col2rgb(hex)
  # Luma formula (standard for perceptual brightness)
  brightness <- (0.299*rgb[1] + 0.587*rgb[2] + 0.114*rgb[3])
  if (brightness > 150) "black" else "white"
}


geom_label_order <- function(data, mapping) {
  geom_text(
    data = data,
    mapping = mapping,
    color = sapply(color_values[data$sample_name], ideal_text_color),
    size = 2.5,
    fontface = "bold",
    vjust = 0.35,
    show.legend = FALSE
  )
}

log_line <- function(...) {
  cat(format(Sys.time(), "%F %T"), " | ", ..., "\n",
      file = logfile, append = TRUE, sep = "")
}


process_one_injection <- function(filename, df, high_res_directory) {
  df_to_be_joined <- df %>%
    dplyr::distinct(scan.no, .keep_all = TRUE) %>%
    dplyr::select(scan.no, sample_name, sample_order, time.min, ions.incremental, tic, it.ms, oic, analyzerTemperature)

  # identify duplicates
  dups_summary <- df %>%
    dplyr::summarise(n = dplyr::n(), .by = c(scan.no, isotopocule)) %>%
    dplyr::filter(n > 1L)
  
  # if any duplicates, message the user
  if (nrow(dups_summary) > 0) {
    message(
      "Note: removed ", sum(dups_summary$n - 1),
      " duplicated rows across ", nrow(dups_summary),
      " scan.no/isotopocule combinations."
    )
  }
  
  # drop duplicates (keep first row for each scan.no + isotopocule)
  df_nodups <- df %>%
    dplyr::group_by(scan.no, isotopocule) %>%
    dplyr::slice(1L) %>%        # or dplyr::distinct(scan.no, isotopocule, .keep_all = TRUE)
    dplyr::ungroup()
  
  # original block, now using df_nodups
  df_wide <- df_nodups %>%
    tidyr::pivot_wider(
      id_cols = scan.no,
      names_from  = isotopocule,
      values_from = ratio,
      names_glue  = "R{isotopocule}"
    ) %>%
    dplyr::left_join(df_to_be_joined, by = "scan.no")
  

  needed <- c("R34S","R33S","R17O","R18O")
  for (nm in needed) if (!nm %in% names(df_wide)) df_wide[[nm]] <- NA_real_

  
  # ------- Define Injection Peak -------
  smoothing_window <- 20
  kernel <- rep(1 / smoothing_window, smoothing_window)
  tic_convolved <- stats::filter(df_wide$tic, kernel, sides = 2)
  
  convolve_df <- data.frame(
    dtic = as.numeric(diff(tic_convolved)),
    dT = diff(df_wide$time.min * 60)
  )
  convolve_df$dtic_dT <- convolve_df$dtic / convolve_df$dT
  convolve_df$time_min <- df_wide$time.min[2:nrow(df_wide)]
  
  ruby_start_window <- which(df_wide$time.min>0 & df_wide$time.min<2)
  ruby_start <- df_wide$time.min[ruby_start_window[which.max(convolve_df$dtic_dT[ruby_start_window])]]
  ruby_end_window <- which(df_wide$time.min>2 & df_wide$time.min<6)
  ruby_end <- df_wide$time.min[ruby_end_window[which.min(convolve_df$dtic_dT[ruby_end_window])]]
  
  ruby_start_index <- which(convolve_df$time_min==ruby_start)
  ruby_end_index <- which(convolve_df$time_min==ruby_end)
  trimmed_window <- which(convolve_df$dtic_dT[ruby_start_index:ruby_end_index]<5e6 &
                          convolve_df$dtic_dT[ruby_start_index:ruby_end_index]>-5e6)
  
  if (PEAK_DEFINITION_STRATEGY=='smoothed_derivative'){
    ruby_start <- min(convolve_df$time_min[ruby_start_index:ruby_end_index][trimmed_window])
    ruby_end <- max(convolve_df$time_min[ruby_start_index:ruby_end_index][trimmed_window])
  } else if (PEAK_DEFINITION_STRATEGY=='trimmed_median'){
    ruby_start <- SAMPLE_PEAK_START
    ruby_end <- SAMPLE_PEAK_END
  } else if (PEAK_DEFINITION_STRATEGY=='combined'){
    ruby_start <- min(convolve_df$time_min[ruby_start_index:ruby_end_index][trimmed_window])
    ruby_end <- max(convolve_df$time_min[ruby_start_index:ruby_end_index][trimmed_window])
  } else if (PEAK_DEFINITION_STRATEGY=='manual'){
    ruby_start <- SAMPLE_PEAK_START
    ruby_end <- SAMPLE_PEAK_END
  } else {
    message(paste0("PEAK_DEFINITION_STRATEGY was entered as ",
                   PEAK_DEFINITION_STRATEGY,
                   " and is not recognized. Your options are 'smoothed_derivative', 'trimmed_median', 'combined', 'manual'"))
    knitr::knit_exit()
  }
    
  df_clean <- df_wide |> dplyr::filter(
                                       (is.na(ruby_start) | time.min > ruby_start),
                                       (is.na(ruby_end)   | time.min < ruby_end))

  if (PEAK_DEFINITION_STRATEGY=='trimmed_median' || PEAK_DEFINITION_STRATEGY=='combined'){
    median_tic <- median(df_clean$tic)
    df_clean <- subset(df_clean, tic/median_tic>0.8 & tic/median_tic<1.2)
  }
  
  # ----- OIC Outlier Removal -----
  nrow_before <- nrow(df_clean)
  mean_oic <- mean(df_clean$oic)
  sd_oic <- sd(df_clean$oic)
  upper_oic <- mean_oic + sd_oic*2
  lower_oic <- mean_oic - sd_oic*2
  df_clean <- subset(df_clean, oic>lower_oic & oic<upper_oic)
  nrow_after <- nrow(df_clean)
  oic_title <- paste0("OIC vs time; ",nrow_before-nrow_after, " outliers found.")

  injection_summary <- df_clean %>%
    dplyr::summarize(
      run = !!run_name,
      sample_name = dplyr::first(sample_name),
      sample_order = dplyr::first(sample_order),
      ruby_start = !!ruby_start,
      ruby_end = !!ruby_end,
      n = dplyr::n(),
      TICmean = mean(tic, na.rm = TRUE),
      TICsd = sd(tic, na.rm = TRUE),
      OICmean = mean(oic, na.rm = TRUE),
      OICsd = sd(oic, na.rm = TRUE),
      analyzerTmean = mean(analyzerTemperature, na.rm = TRUE),
      analyzerTsd = sd(analyzerTemperature, na.rm = TRUE),
      R34Smean = mean(R34S, na.rm = TRUE),
      R34Ssd = sd(R34S, na.rm = TRUE),
      R33Smean = mean(R33S, na.rm = TRUE),
      R33Ssd = sd(R33S, na.rm = TRUE),
      R18Omean = mean(R18O, na.rm = TRUE),
      R18Osd = sd(R18O, na.rm = TRUE),
      R17Omean = mean(R17O, na.rm = TRUE),
      R17Osd = sd(R17O, na.rm = TRUE)
    ) %>%
    tidyr::replace_na(list(
      sample_name = unique(df_wide$sample_name)[1],
      sample_order = unique(df_wide$sample_order)[1]
    ))

  p1 <- ggplot() +
    geom_line(data=df_wide, aes(x = time.min, y = tic), color="black", linewidth=2) +
    geom_line(data=df_clean, aes(x = time.min, y = tic), color="yellow", linewidth=1) +
    geom_vline(xintercept = ruby_start, linetype = "solid", color = "green", linewidth = 1) +
    geom_vline(xintercept = ruby_end,   linetype = "solid", color = "red",   linewidth = 1) +
    labs(title = "TIC vs time", x = "Time (minutes)", y = "TIC") +
    scale_x_continuous(breaks = seq(0, 13, by = 1)) +
    theme_minimal()

  p2 <- ggplot(convolve_df) +
    geom_line(aes(x = time_min, y = dtic_dT)) +
    labs(title = "dtic_dT vs time", x = "Time (minutes)", y = "dTIC/dT") +
    geom_vline(xintercept = ruby_start, linetype = "solid", color = "green", linewidth = 1) +
    geom_vline(xintercept = ruby_end,   linetype = "solid", color = "red",   linewidth = 1) +
    scale_x_continuous(breaks = seq(0, 13, by = 1)) +
    theme_minimal()

  p3 <- ggplot() +
    geom_line(data=df_wide, aes(x = time.min, y = oic), color="black", linewidth=2) +
    geom_line(data=df_clean, aes(x = time.min, y = oic), color="yellow", linewidth=1) +
    geom_vline(xintercept = ruby_start, linetype = "solid", color = "green", linewidth = 1) +
    geom_vline(xintercept = ruby_end,   linetype = "solid", color = "red",   linewidth = 1) +
    labs(title = oic_title, x = "Time (minutes)", y = "OIC") +
    scale_x_continuous(breaks=seq(0, 13, by=1), limits=c(0,ruby_end+1)) +
    scale_y_continuous(
      limits = c(min(df_clean$oic, na.rm = TRUE),
                 max(df_clean$oic, na.rm = TRUE))) +
    theme_minimal()
  
  png1 <- fs::path(high_res_directory, sprintf('%s_fig_%d.png', filename, 1))
  png2 <- fs::path(high_res_directory, sprintf('%s_fig_%d.png', filename, 2))
  png3 <- fs::path(high_res_directory, sprintf('%s_fig_%d.png', filename, 3))
  
  ggsave(png1, p1, device = ragg::agg_png, width = 5, height = 3, units = "in", dpi = 100)
  ggsave(png2, p2, device = ragg::agg_png, width = 5, height = 3, units = "in", dpi = 100)
  ggsave(png3, p3, device = ragg::agg_png, width = 5, height = 3, units = "in", dpi = 100)

  list(
    filename = filename,
    scanlimits = c(min(df_clean$scan.no), max(df_clean$scan.no)),
    row = injection_summary,
    images = c(png1, png2, png3)
  )
} # end process_one_injection


process_one_raw_file <- function(raw_file, high_res_directory, basepeak) {
  filename <- tools::file_path_sans_ext(basename(raw_file))

  raw_agg_file <- raw_file |>
    orbi_read_raw(include_spectra = FALSE) |>
    orbi_aggregate_raw()

  isoraw <- orbi_get_data(
    raw_agg_file,
    file_info = c("filename"),
    scans     = tidyselect::everything(),
    peaks     = tidyselect::everything(),
    spectra   = NULL,
    problems  = NULL,
    summary   = NULL,
    by        = c("uidx", "scan.no")
  )

  isoraw <- orbi_identify_isotopocules(
    isoraw,
    isotopocules      = ISOTOPOCULES,
    default_tolerance = 0.6,
    default_charge    = 1
  )
  isoraw <- orbi_filter_isotopocules(isoraw, isotopocules = names(ISOTOPOCULES))
  isoraw <- orbi_calculate_ions(isoraw, CN = 3, RN = 240000)

  isoraw$sample_name  <- gsub("-", "_", sub("_.*", "", isoraw$filename))
  isoraw$sample_order <- as.numeric(sub(".*_", "", isoraw$filename))
  isoraw$oic          <- isoraw$tic * isoraw$it.ms / 1000
  isoraw              <- orbi_define_basepeak(isoraw, basepeak_def = basepeak)
  isoraw              <- subset(isoraw, time.min > 0.2)

  # main per-injection processing
  inj <- process_one_injection(filename, isoraw, high_res_directory)

  # make M0/M1/M2 diagnostic scatter plots using inj$scanlimits
  peaks <- subset(
    raw_agg_file$peaks,
    (scan.no > inj$scanlimits[1]) & (scan.no < inj$scanlimits[2])
  )

  limit_offset <- 0.020
  M0_limits <- c(ISOTOPOCULES['M0']-limit_offset, ISOTOPOCULES['M0']+limit_offset)
  M1_limits <- c(ISOTOPOCULES['33S']-limit_offset, ISOTOPOCULES['33S']+limit_offset)
  M2_limits <- c(ISOTOPOCULES['34S']-limit_offset, ISOTOPOCULES['34S']+limit_offset)

  plots_df <- list(
    list(df = peaks[peaks$mzMeasured > M0_limits[1] & peaks$mzMeasured < M0_limits[2], ], ttl = "M0", lims = M0_limits, idx = 4),
    list(df = peaks[peaks$mzMeasured > M1_limits[1] & peaks$mzMeasured < M1_limits[2], ], ttl = "M1 - 33S and 17O", lims = M1_limits, idx = 5),
    list(df = peaks[peaks$mzMeasured > M2_limits[1] & peaks$mzMeasured < M2_limits[2], ], ttl = "M2 - 34S and 18O", lims = M2_limits, idx = 6)
  )

  # dir_create(HIGH_RES_DIRECTORY, recurse = TRUE)

  mz_zoomed_figs <- purrr::map_chr(plots_df, function(x) {
    p <- ggplot(x$df) +
      geom_point(aes(x = mzMeasured, y = intensity)) +
      labs(title = x$ttl, x = "mz Measured", y = "Intensity") +
      xlim(x$lims[1], x$lims[2]) +
    theme_minimal()
    out <- fs::path(high_res_directory, sprintf("%s_fig_%d.png", filename, x$idx))
    ggsave(out, p, device = ragg::agg_png, width = 5, height = 3, units = "in", dpi = 100)
    out
  })

  full_mzRange <- fs::path(
    high_res_directory,
    sprintf("%s_fig_full_mzRange.png", filename)
  )
  
  xlim_min <- min(ISOTOPOCULES)-2
  xlim_max <- max(ISOTOPOCULES)+2

  full_mzRange_fig <- ggplot() +
    geom_vline(data=iso_df, aes(xintercept=mz), linetype="solid",color="gray", linewidth=0.5) +
    geom_point(data=peaks, aes(x = mzMeasured, y = intensity), size = 0.3, alpha = 0.6) +
    xlim(xlim_min, xlim_max) +
    ylim(0, 1e8) +
    scale_x_continuous(breaks = seq(xlim_min, xlim_max, by = 1)) +
    labs(title = sprintf("%s — full m/z range", filename), x = "mz Measured", y = "Intensity") +
    theme_minimal()
  
  # wider but same height as mz_zoomed_figs
  ggsave(full_mzRange, full_mzRange_fig,
         device = ragg::agg_png,
         width  = 10,  # wider
         height = 3,   # same height as mz_zoomed_figs
         units  = "in",
         dpi    = 100)
  
  ppm_tol <- 3  # 5 ppm tolerance
  
  peaks_clustered <- peaks %>%
    arrange(mzMeasured) %>%
    mutate(
      grp = cumsum(c(TRUE, diff(mzMeasured) > mzMeasured[-n()] * ppm_tol * 1e-6))
    ) %>%
    group_by(grp) %>%
    summarise(
      mean_mz = mean(mzMeasured),
      peak_intensity = max(intensity),
      n = n()
    ) %>%
    arrange(desc(peak_intensity))
  inj$largest_peaks <- head(peaks_clustered, 10)
  
  inj$images <- c(inj$images, mz_zoomed_figs)
  inj$full_mzRange_image <- full_mzRange
  inj
} # end process_one_raw_file

  
compute_ref <- function(before, after, diff_temp_before, diff_temp_after) {
  if (!is.na(diff_temp_before) & diff_temp_before < ABS_DELTA_T_THRESHOLD & !is.na(diff_temp_after) & diff_temp_after < ABS_DELTA_T_THRESHOLD) {
    return(mean(c(before, after), na.rm = TRUE))
  } else if (!is.na(diff_temp_before) & diff_temp_before < ABS_DELTA_T_THRESHOLD) {
    return(before)
  } else if (!is.na(diff_temp_after) & diff_temp_after < ABS_DELTA_T_THRESHOLD) {
    return(after)
  } else {
    return(NaN)
  }
}


find_nearest <- function(sample_order, reference_orders) {
  before <- max(reference_orders[reference_orders < sample_order], na.rm = TRUE)
  after <- min(reference_orders[reference_orders > sample_order], na.rm = TRUE)
  
  # Replace Inf/-Inf with NA if no valid before or after exists
  before <- ifelse(is.finite(before), before, NA)
  after <- ifelse(is.finite(after), after, NA)
  
  return(c(before, after))
}


plot_temperature <- function(samples_data_frame, xM0){
  Fig__AnalyzerT_vs_order <- ggplot(data = samples_data_frame) +
  geom_errorbar(aes(x = sample_order, 
                    ymin = analyzerTmean - analyzerTsd*2, 
                    ymax = analyzerTmean + analyzerTsd*2, 
                    color = sample_name),
                width = 0.2,
                linewidth = 1) +
  geom_point(aes(x = sample_order, y = analyzerTmean, shape=sample_name, fill=sample_name), size=6) +
        scale_color_manual(values=color_values) +
        scale_shape_manual(values=shape_values) +
        scale_fill_manual(values=color_values) +
  geom_label_order(samples_data_frame, aes(x = sample_order, y = analyzerTmean, label = sample_order)) +
  labs(
    title = paste0(xM0, " - Analyzer temperature vs sample order. Error bars are 2sd. Threshold = ", ABS_DELTA_T_THRESHOLD),
    x = "Sample order",
    y = "Mean Analyzer Temp (*C)")
  print(Fig__AnalyzerT_vs_order)
}

```

## Introduction

Our working script to process sulfate data from Ivan (a Thermo Exploris 240 Orbitrap Mass Spectrometer), Ruby (an HPLC), and, on occasion, Stella (a syringe and pump), all located in IsoLab, UW. This R Markdown grew from the R script "CalculateDeltas.R" and can be found on github at [sulfate](https://github.com/andyschauer/sulfate).

At the top of the .Rmd file, find the THINGS YOU MAY WANT TO CHANGE RUN TO RUN for just that. The current state of those things is shown below:

<details><summary class="expandable_subtitles">Data Processing Settings</summary>

  **Thresholds**:
  
  - ABS_DELTA_T_THRESHOLD = `r ABS_DELTA_T_THRESHOLD`

  **Chosen Calibration Standards**:

  - d17O_CALIBRATION_STANDARDS = `r d17O_CALIBRATION_STANDARDS`
  - d18O_CALIBRATION_STANDARDS = `r d18O_CALIBRATION_STANDARDS`
  - d33S_CALIBRATION_STANDARDS = `r d33S_CALIBRATION_STANDARDS`
  - d34S_CALIBRATION_STANDARDS = `r d34S_CALIBRATION_STANDARDS`

  **Previous Ideal Calibration Standards** - Agreed upon calibration standards as of 2025-05-22:

| Purpose     | d34S        | d17O & d18O |
| ----------- | ----------- | ----------- |
| calibration | S_MIF_2     | SodSul_6    | 
| calibration | SodSul_4    | S_foxtrot   | 
| check       | SodSul_2    | S_charlie   | 

  **Updated Ideal Calibration Standards** - Agreed upon calibration standards as of 2025-10-27:

| Purpose     | d34S        | d17O & d18O |
| ----------- | ----------- | ----------- |
| calibration | S_MIF_2     | SodSul_6    | 
| calibration | SodSul_8    | S_delta     | 
| check       | SodSul_4    | S_bravo     | 
| check       | SodSul_2    |             | 


  **wM0 Samples to ignore**: `r wM0_SAMPLES_TO_IGNORE`
  **noM0 Samples to ignore**: `r noM0_SAMPLES_TO_IGNORE`

  **Sample Peak Definition**:

  - PEAK_DEFINITION_STRATEGY = `r PEAK_DEFINITION_STRATEGY` (`r SAMPLE_PEAK_START` to `r SAMPLE_PEAK_END`)
    - Current options are: 'smoothed_derivative', 'trimmed_median', 'combined', 'manual'. 'smoothed_derivative' is the method we have been working with for some time. 'trimmed_median' is from Jack\'s manuscript. 'combined' is both. 'manual' is, well, I am sure you get it by now.


  If you wish to work with the data interactively, after rendering this markdown file, run the following code:

  - rm(list=ls())
  - load('workspace.RData')

</details>

```{r file-and-directory-setup, echo=FALSE, include=FALSE}

DATA_DIRECTORY              <-    "/home/disk/melvin/OrbiData/Ruby"
REFERENCE_MATERIALS_FILE    <-    "/home/disk/melvin/OrbiData/reference_materials/reference_materials.json"

run_name                    <-    basename(getwd())
wM0_HIGH_RES_DIRECTORY      <-    file.path(DATA_DIRECTORY, run_name, "wM0_high_res")
noM0_HIGH_RES_DIRECTORY     <-    file.path(DATA_DIRECTORY, run_name, "noM0_high_res")
wM0_DIRECTORY               <-    file.path(DATA_DIRECTORY, run_name, "wM0")
noM0_DIRECTORY              <-    file.path(DATA_DIRECTORY, run_name, "noM0")

wM0_raw_files      <- orbi_find_raw(wM0_DIRECTORY)
if (!dir.exists(wM0_HIGH_RES_DIRECTORY)) {
  dir.create(wM0_HIGH_RES_DIRECTORY, recursive = TRUE)
}

logfile <- file.path(getwd(), "render.log")

# stopifnot(length(wM0_raw_files) > 0)

if (dir.exists(noM0_DIRECTORY)) {
  noM0 <- TRUE
  noM0_raw_files <- orbi_find_raw(noM0_DIRECTORY)
  log_line("noM0 files: ", length(noM0_raw_files))
  if (!dir.exists(noM0_HIGH_RES_DIRECTORY)) {
    dir.create(noM0_HIGH_RES_DIRECTORY, recursive = TRUE)
  }
} else {
  noM0 <- FALSE
  log_line("noM0 directory does not exist")
}

dir.create("figures", recursive = TRUE, showWarnings = FALSE)
```

```{r read-reference-materials-json, include=FALSE, echo=FALSE}
ref_mat <- fromJSON(REFERENCE_MATERIALS_FILE)

all_sulfate_keys <- names(ref_mat$sulfates)
sodium_sulfate_keys <- keep(
  all_sulfate_keys,
  ~ {
    m <- pluck(ref_mat, "sulfates", .x, "material", .default = NA_character_)
    !is.na(m) && tolower(trimws(m)) == "sodium sulfate"
  }
)
```

```{r parallel-processing-setup, echo=FALSE, include=FALSE, eval=TRUE}
Sys.setenv(
  OMP_NUM_THREADS = "1",
  MKL_NUM_THREADS = "1",
  OPENBLAS_NUM_THREADS = "1",
  NUMEXPR_NUM_THREADS = "1"
)

all_cores <- future::availableCores()
reserve   <- 10
workers   <- max(1, min(32, all_cores) - reserve)
message(sprintf("Using %d workers (available=%d, reserve=%d).", workers, all_cores, reserve))
plan(multisession, workers = workers)

opts <- furrr::furrr_options(
  seed = TRUE,
  scheduling = 2,
  packages  = c("dplyr","tidyr","purrr","ggplot2","fs","tools","stringr")
)

safe_one <- purrr::safely(process_one_raw_file, otherwise = NULL)
```

```{r read-wM0-raw-files, echo=FALSE, include=FALSE, eval=TRUE}

# remove samples to ignore from list of raw files
wM0_sample_names <- sub('\\.raw$', "", basename(wM0_raw_files))
wM0_raw_files <- wM0_raw_files[!wM0_sample_names %in% wM0_SAMPLES_TO_IGNORE]

wM0_sample_order <- as.integer(sub(".*_(\\d+)\\.raw$", "\\1", wM0_raw_files))
wM0_raw_files <- wM0_raw_files[order(wM0_sample_order)]

# decide based on first raw file if we have measured SO3 or HSO4
raw_agg_file <- wM0_raw_files[1] |> orbi_read_raw(include_spectra = FALSE) |> orbi_aggregate_raw()
if (raw_agg_file$file_info$LowMass<81){
  # SO3
  ISOTOPOCULES <- c("M0"=79.95736,
                    "33S"=80.95675,
                    "17O"=80.96158,
                    "34S"=81.95316,
                    "18O"=81.96161)
} else if (raw_agg_file$file_info$LowMass>90){
#  HSO4
  ISOTOPOCULES <- c("M0"=96.96010,
                    "33S"=97.95949,
                    "17O"=97.96432,
                    "34S"=98.95590,
                    "18O"=98.96435)

}
iso_df <- data.frame(
  label = names(ISOTOPOCULES),
  mz    = as.numeric(ISOTOPOCULES)
)

each_wM0_injection <- list()


wM0_results <- furrr::future_map(
  wM0_raw_files,
  ~ safe_one(.x, wM0_HIGH_RES_DIRECTORY, "M0"),
  .options = opts
)

wM0_named_results <- purrr::set_names(wM0_results, tools::file_path_sans_ext(basename(wM0_raw_files)))

each_wM0_injection <- wM0_named_results |>
  purrr::keep(~ is.null(.x$error)) |>
  purrr::map("result")

wM0_errs <- wM0_named_results |>
  purrr::keep(~ !is.null(.x$error)) |>
  purrr::imap(\(x, fname) {
    tibble(
      filename = fname,
      message  = conditionMessage(x$error),
      class    = paste(class(x$error), collapse = "/")
    )
  }) |>
  dplyr::bind_rows()
```

```{r read-noM0-raw-files, echo=FALSE, include=FALSE, eval=TRUE}

if (noM0==TRUE){
  # remove samples to ignore from list of raw files
  noM0_sample_names <- sub('\\.raw$', "", basename(noM0_raw_files))
  noM0_raw_files <- noM0_raw_files[!noM0_sample_names %in% noM0_SAMPLES_TO_IGNORE]

  noM0_sample_order <- as.integer(sub(".*_(\\d+)\\.raw$", "\\1", noM0_raw_files))
  noM0_raw_files <- noM0_raw_files[order(noM0_sample_order)]


  # decide based on first raw file if we have measured SO3 or HSO4
  raw_agg_file <- noM0_raw_files[1] |> orbi_read_raw(include_spectra = FALSE) |> orbi_aggregate_raw()
  log_line(noM0_raw_files[1])
  if (raw_agg_file$file_info$LowMass<81){
    # SO3
    ISOTOPOCULES <- c("M0"=79.95736,
                      "33S"=80.95675,
                      "17O"=80.96158,
                      "34S"=81.95316,
                      "18O"=81.96161)
  } else if (raw_agg_file$file_info$LowMass>90){
  #  HSO4
    ISOTOPOCULES <- c("M0"=96.96010,
                      "33S"=97.95949,
                      "17O"=97.96432,
                      "34S"=98.95590,
                      "18O"=98.96435)

  }
  iso_df <- data.frame(
    label = names(ISOTOPOCULES),
    mz    = as.numeric(ISOTOPOCULES)
  )


  each_noM0_injection <- list()

  noM0_results <- furrr::future_map(
    noM0_raw_files,
    ~ safe_one(.x, noM0_HIGH_RES_DIRECTORY, "34S"),
    .options = opts
  )

  noM0_named_results <- purrr::set_names(noM0_results, tools::file_path_sans_ext(basename(noM0_raw_files)))

  each_noM0_injection <- noM0_named_results |>
    purrr::keep(~ is.null(.x$error)) |>
    purrr::map("result")

  noM0_errs <- noM0_named_results |>
    purrr::keep(~ !is.null(.x$error)) |>
    purrr::imap(\(x, fname) {
      tibble(
        filename = fname,
        message  = conditionMessage(x$error),
        class    = paste(class(x$error), collapse = "/")
      )
    }) |>
    dplyr::bind_rows()
}
```

```{r wM0-high-resolution-data-processing, echo=FALSE, include=FALSE}
largest_peaks  <- purrr::map(each_wM0_injection, "largest_peaks")
largest_peaks_tbl <- purrr::imap_dfr(
  largest_peaks,
  ~ {
    if (is.null(.x) || nrow(.x) == 0) return(NULL)
    dplyr::mutate(.x, sample_id = .y)
  }
)

largest_peaks_tbl <- largest_peaks_tbl %>%
  mutate(
    sample_order = as.integer(str_extract(sample_id, "\\d+$")),
    sample_name  = str_remove(sample_id, "_\\d+$")
  )

readr::write_csv(largest_peaks_tbl, paste0(DATA_DIRECTORY, "/__Measured_Peaks__/", run_name, "_wM0_largest_peaks.csv"))

wM0_rows           <- purrr::map(each_wM0_injection, "row")
wM0_ruby_data_summary <- dplyr::bind_rows(wM0_rows)

for (i in seq_along(each_wM0_injection)) {
  rec <- each_wM0_injection[[i]]
  if (!is.null(rec$largest_peaks) && nrow(rec$largest_peaks) > 0) {
    first_intensity <- rec$largest_peaks$peak_intensity[1]
    wM0_ruby_data_summary$first_peak_intensity[i] <- first_intensity
    }
  }
```

```{r noM0-high-resolution-data-processing, echo=FALSE, include=FALSE}
if (noM0 == TRUE) {

  # ---- 1) Build the main summary table FIRST ----
  noM0_rows <- purrr::map(each_noM0_injection, "row")
  noM0_ruby_data_summary <- dplyr::bind_rows(noM0_rows)

  # ---- 2) Build peaks table ----
  noM0_largest_peaks <- purrr::map(each_noM0_injection, "largest_peaks")
  noM0_largest_peaks_tbl <- purrr::imap_dfr(
    noM0_largest_peaks,
    ~{
      if (is.null(.x) || nrow(.x) == 0) return(NULL)
      dplyr::mutate(.x, sample_id = .y)   # .y = list element name
    }
  )

  if (nrow(noM0_largest_peaks_tbl) > 0) {

    # ---- 3) Add keys (sample_name, sample_order) derived from sample_id ----
    noM0_largest_peaks_tbl <- noM0_largest_peaks_tbl %>%
      dplyr::mutate(
        sample_order = as.integer(stringr::str_extract(sample_id, "\\d+$")),
        sample_name  = stringr::str_remove(sample_id, "_\\d+$")
      )

    # ---- 4) Summarise to one value per analysis ----
    noM0_first_intensity_tbl <- noM0_largest_peaks_tbl %>%
      dplyr::group_by(sample_name, sample_order) %>%
      dplyr::summarise(first_peak_intensity = max(peak_intensity), .groups = "drop")

    # ---- 5) Join into summary (order-proof) ----
    noM0_ruby_data_summary <- noM0_ruby_data_summary %>%
      dplyr::mutate(sample_order = as.integer(sample_order)) %>%  # type safety
      dplyr::left_join(noM0_first_intensity_tbl, by = c("sample_name", "sample_order"))

  } else {
    # Ensure the column exists even if there are no peaks
    noM0_ruby_data_summary$first_peak_intensity <- NA_real_
  }

  # ---- 6) Optional export ----
  readr::write_csv(
    noM0_largest_peaks_tbl,
    paste0(DATA_DIRECTORY, "/__Measured_Peaks__/", run_name, "_noM0_largest_peaks.csv")
  )
}
```

```{r determine-standards-present, echo=FALSE, include=FALSE}
BRACKETING_REFERENCE <- unique(wM0_ruby_data_summary$sample_name)[
  grepl("_ref$", unique(wM0_ruby_data_summary$sample_name))
]
```

<details><summary class="expandable_subtitles">High Resolution Summary</summary>


```{r figure-style, echo=FALSE, include=FALSE}
sulfate_figure_theme <- theme_minimal() +
                        theme(
                          axis.line = element_line(color = "black", linewidth = 1),
                          panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
                          legend.position = "right",
                          legend.text = element_text(size = 14),
                          plot.title = element_text(size = 16, face = "bold"),
                          axis.title = element_text(size = 14),
                          axis.text = element_text(size = 12))
theme_set(sulfate_figure_theme)

STANDARD_COLORS <- c(
  setNames("#faad1e", BRACKETING_REFERENCE),
  "SodSul_2" = "#1b9e77",
  "SodSul_4" = "#d95f02",
  "SodSul_6" = "#66a61e",
  "SodSul_8" = "#7570b3",
  "S_bravo"  = "#e6ab02",
  "S_delta"  = "#a6761d",
  "S_MIF_1"  = "#666666",
  "S_MIF_2"  = "#e7298a"
)

STANDARD_SHAPES <- c(
  setNames(22, BRACKETING_REFERENCE),
  "SodSul_2" = 23,
  "SodSul_4" = 23,
  "SodSul_6" = 25,
  "SodSul_8" = 24,
  "S_bravo"  = 23,
  "S_delta"  = 25,
  "S_MIF_1"  = 23,
  "S_MIF_2"  = 24
)
NONSTANDARD_PALETTE <- viridis

all_levels <- levels(factor(wM0_ruby_data_summary$sample_name))
standards_present <- intersect(sodium_sulfate_keys, all_levels)
standards_present <- c(standards_present, BRACKETING_REFERENCE)
nonstandards_present <- setdiff(all_levels, standards_present)

n_non <- length(nonstandards_present)

color_values <- setNames(rep(NA, length(all_levels)), all_levels)
color_values[standards_present] <- STANDARD_COLORS[standards_present]
if (n_non > 0) {
  color_values[nonstandards_present] <- NONSTANDARD_PALETTE(n_non)
}
shape_values <- setNames(rep(21, length(all_levels)), all_levels)  # default circle
shape_values[standards_present] <- STANDARD_SHAPES[standards_present]
```


```{r wM0-high-res-summary-figures, fig.width=12, fig.height=8, fig.show='hold', echo=FALSE}
knitr::opts_chunk$set(fig.show = "hold")
fig_n <- 1
run_figures <- list()

title_text =  sprintf("wM0 Figure %d - TIC vs sample order", fig_n)
run_figures[[fig_n]] <- list(
    title_text =  title_text,
    anchor = sprintf("fig%d", fig_n),
    caption_text = "Total Ion Count versus sample order",
    plot = ggplot(wM0_ruby_data_summary) + 
        geom_errorbar(aes(x = sample_order, ymin = TICmean - TICsd, ymax = TICmean + TICsd, color = sample_name),
                      width = 0.2, linewidth = 1) +
        geom_point(aes(x=sample_order, y=TICmean, shape=sample_name, fill=sample_name), size=6) +
        scale_color_manual(values=color_values) +
        scale_shape_manual(values=shape_values) +
        scale_fill_manual(values=color_values) +
        geom_text(aes(x = sample_order, y = TICmean, label = sample_order), 
                  color = sapply(color_values[wM0_ruby_data_summary$sample_name], ideal_text_color),
                  size = 2.5, fontface = "bold", vjust = 0.35) +
        labs(title = title_text))
print(run_figures[[fig_n]]$plot)

fig_n <- fig_n + 1

title_text =  sprintf("wM0 Figure %d - OIC vs sample order", fig_n)
run_figures[[fig_n]] <- list(
    title_text =  title_text,
    anchor = sprintf("fig%d", fig_n),
    caption_text = "Orbitrap Ion Count versus sample order",
    plot = ggplot(wM0_ruby_data_summary) + 
        geom_errorbar(aes(x = sample_order, ymin = OICmean - OICsd, ymax = OICmean + OICsd, color = sample_name),
                      width = 0.2, linewidth = 1) +
        geom_point(aes(x=sample_order, y=OICmean, shape=sample_name, fill=sample_name), size = 6) +
        scale_color_manual(values=color_values) +
        scale_shape_manual(values=shape_values) +
        scale_fill_manual(values=color_values) +
        geom_text(aes(x = sample_order, y = OICmean, label = sample_order), 
                  color = sapply(color_values[wM0_ruby_data_summary$sample_name], ideal_text_color),
                  size = 2.5, fontface = "bold", vjust = 0.35) +  
        labs(title = title_text))
print(run_figures[[fig_n]]$plot)
```

```{r noM0-high-res-summary-figures, fig.width=12, fig.height=8, fig.show='hold', echo=FALSE}
if (noM0==TRUE){
  knitr::opts_chunk$set(fig.show = "hold")
  fig_n <- fig_n + 1

  title_text =  sprintf("noM0 Figure %d - TIC vs sample order", fig_n)
  run_figures[[fig_n]] <- list(
      title_text =  title_text,
      anchor = sprintf("fig%d", fig_n),
      caption_text = "Total Ion Count versus sample order",
      plot = ggplot(noM0_ruby_data_summary) + 
          geom_errorbar(aes(x = sample_order, ymin = TICmean - TICsd, ymax = TICmean + TICsd, color = sample_name),
                        width = 0.2, linewidth = 1) +
          geom_point(aes(x=sample_order, y=TICmean, shape=sample_name, fill=sample_name), size=6) +
          scale_color_manual(values=color_values) +
          scale_shape_manual(values=shape_values) +
          scale_fill_manual(values=color_values) +
          geom_text(aes(x = sample_order, y = TICmean, label = sample_order), 
                    color = sapply(color_values[noM0_ruby_data_summary$sample_name], ideal_text_color),
                    size = 2.5, fontface = "bold", vjust = 0.35) +
          labs(title = title_text))
  print(run_figures[[fig_n]]$plot)

  fig_n <- fig_n + 1

  title_text =  sprintf("noM0 Figure %d - OIC vs sample order", fig_n)
  run_figures[[fig_n]] <- list(
      title_text =  title_text,
      anchor = sprintf("fig%d", fig_n),
      caption_text = "Orbitrap Ion Count versus sample order",
      plot = ggplot(noM0_ruby_data_summary) + 
          geom_errorbar(aes(x = sample_order, ymin = OICmean - OICsd, ymax = OICmean + OICsd, color = sample_name),
                        width = 0.2, linewidth = 1) +
          geom_point(aes(x=sample_order, y=OICmean, shape=sample_name, fill=sample_name), size = 6) +
          scale_color_manual(values=color_values) +
          scale_shape_manual(values=shape_values) +
          scale_fill_manual(values=color_values) +
          geom_text(aes(x = sample_order, y = OICmean, label = sample_order), 
                    color = sapply(color_values[noM0_ruby_data_summary$sample_name], ideal_text_color),
                    size = 2.5, fontface = "bold", vjust = 0.35) +  
          labs(title = title_text))
  print(run_figures[[fig_n]]$plot)
}
```

</details>

<details><summary class="expandable_subtitles">High Resolution wM0 Individual Injections</summary>


```{r emit-wM0-sample-sections, results='asis', comment=NA, echo=FALSE, message=FALSE, warning=FALSE}

for (rec in each_wM0_injection) {
  cat(sprintf('<details class="high_res_sample"><summary>%s</summary>\n', rec$filename))

  # --- Row 1: small zoomed images -----------------------------------------
  cat('<div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-bottom:0.5rem;">\n')
  for (img in rec$images) {
    cat(sprintf(
      '<img src="%s" style="max-width:30%%; height:auto;">\n',
      img
    ))
  }
  cat('</div>\n')

  # --- Row 2: full-range image + Ten largest peaks table side-by-side -----
  if (!is.null(rec$full_mzRange_image) && !is.null(rec$largest_peaks) && nrow(rec$largest_peaks) > 0) {

    # flex container for image + table
    cat('<div style="display:flex; gap:1rem; align-items:flex-start; margin-bottom:0.5rem;">\n')

    # left: full-range image (~70% of width)
    cat(sprintf(
      '<div style="flex:0 0 70%%;"><img src="%s" style="width:100%%; height:auto;"></div>\n',
      rec$full_mzRange_image
    ))

    # right: table (~30% of width)
    cat('<div style="flex:1;">Ten largest peaks:',
    '<table style="border-collapse:collapse; margin-top:0.5rem;">\n')
    cat('<tr>',
    '<th style="border:1px solid #ccc; padding:4px;">Mean m/z</th>',
    '<th style="border:1px solid #ccc; padding:4px;">Mean Intensity</th>',
    '</tr>\n')
    for (i in seq_len(nrow(rec$largest_peaks))) {
      cat('<tr>',
      sprintf('<td style="border:1px solid #ccc; padding:4px;">%.4f</td>',
      rec$largest_peaks$mean_mz[i]),
      sprintf('<td style="border:1px solid #ccc; padding:4px;">%.0f</td>',
      rec$largest_peaks$peak_intensity[i]),
      '</tr>\n')
    }
    cat('</table></div>\n')  # close right-side div
    cat('</div>\n')         # close flex container
  } else {
    # if you still want to show the full image even when no table:
    if (!is.null(rec$full_mzRange_image)) {
      cat(sprintf(
        '<img src="%s" style="max-width:100%%; height:auto; margin-bottom:0.5rem;">\n',
        rec$full_mzRange_image
        ))
      }
  }

  cat('</details>\n\n')
}

```

</details>


```{r emit-noM0-sample-sections, results='asis', comment=NA, echo=FALSE, message=FALSE, warning=FALSE}

if (noM0==TRUE){
  cat('<details><summary class="expandable_subtitles">High Resolution noM0 Individual Injections</summary>')
  for (rec in each_noM0_injection) {
    cat(sprintf('<details class="high_res_sample"><summary>%s</summary>\n', rec$filename))

    # --- Row 1: small zoomed images -----------------------------------------
    cat('<div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-bottom:0.5rem;">\n')
    for (img in rec$images) {
      cat(sprintf(
        '<img src="%s" style="max-width:30%%; height:auto;">\n',
        img
      ))
    }
    cat('</div>\n')

    # --- Row 2: full-range image + Ten largest peaks table side-by-side -----
    if (!is.null(rec$full_mzRange_image) && !is.null(rec$largest_peaks) && nrow(rec$largest_peaks) > 0) {

      # flex container for image + table
      cat('<div style="display:flex; gap:1rem; align-items:flex-start; margin-bottom:0.5rem;">\n')

      # left: full-range image (~70% of width)
      cat(sprintf(
        '<div style="flex:0 0 70%%;"><img src="%s" style="width:100%%; height:auto;"></div>\n',
        rec$full_mzRange_image
      ))

      # right: table (~30% of width)
      cat('<div style="flex:1;">Ten largest peaks:',
      '<table style="border-collapse:collapse; margin-top:0.5rem;">\n')
      cat('<tr>',
      '<th style="border:1px solid #ccc; padding:4px;">Mean m/z</th>',
      '<th style="border:1px solid #ccc; padding:4px;">Mean Intensity</th>',
      '</tr>\n')
      for (i in seq_len(nrow(rec$largest_peaks))) {
        cat('<tr>',
        sprintf('<td style="border:1px solid #ccc; padding:4px;">%.4f</td>',
        rec$largest_peaks$mean_mz[i]),
        sprintf('<td style="border:1px solid #ccc; padding:4px;">%.0f</td>',
        rec$largest_peaks$peak_intensity[i]),
        '</tr>\n')
      }
      cat('</table></div>\n')  # close right-side div
      cat('</div>\n')         # close flex container
    } else {
      # if you still want to show the full image even when no table:
      if (!is.null(rec$full_mzRange_image)) {
        cat(sprintf(
          '<img src="%s" style="max-width:100%%; height:auto; margin-bottom:0.5rem;">\n',
          rec$full_mzRange_image
          ))
        }
    }

    cat('</details>\n\n')
  }
  cat('</details>\n\n')
}
```

<details><summary class="expandable_subtitles">Analyzer Temperature</summary>

```{r organize-data, echo=FALSE, include=FALSE}
message('\n ---------- sort based on sample order ----------')
wM0_ruby_data_summary <- wM0_ruby_data_summary[order(wM0_ruby_data_summary$sample_order), ]
wM0_ruby_data_summary <- wM0_ruby_data_summary %>%
  rename(
    R34S = R34Smean,
    R33S = R33Smean,
    R18O = R18Omean,
    R17O = R17Omean
  )

if (noM0==TRUE){
  noM0_ruby_data_summary <- noM0_ruby_data_summary[order(noM0_ruby_data_summary$sample_order), ]
  noM0_ruby_data_summary <- noM0_ruby_data_summary %>%
    rename(
      R33S = R33Smean,
      R18O = R18Omean,
      R17O = R17Omean
    )
}
```

Analyzer temperature is stored in the .raw data files. While we still don\'t know where exactly in the instrument this measurement originates, it does track with lab temperature. Furthermore, it also seems to explain much of the ratio variability.

```{r AnalyzerTemperature, echo=FALSE, fig.width=10, fig.height=6}
plot_temperature(wM0_ruby_data_summary, "wM0")
if (noM0==TRUE){
  plot_temperature(noM0_ruby_data_summary, "noM0")
}
```

</details>

```{r wM0-bracketing, include=FALSE, echo=FALSE}
bracketing_references <- subset(wM0_ruby_data_summary, sample_name == BRACKETING_REFERENCE)
wM0_analyses <- subset(wM0_ruby_data_summary, sample_name != BRACKETING_REFERENCE)

wM0_analyses <- wM0_analyses %>%
  rowwise() %>%
  mutate(
    nearest_ref_before = find_nearest(sample_order, bracketing_references$sample_order)[1],
    nearest_ref_after = find_nearest(sample_order, bracketing_references$sample_order)[2]
  ) %>%
  ungroup()

wM0_analyses <- wM0_analyses %>%
  left_join(
    bracketing_references %>%
      select(sample_order, analyzerTmean, TICmean, OICmean, first_peak_intensity) %>%
      rename(nearest_ref_before = sample_order, mean_temp_before = analyzerTmean, TIC_before = TICmean, OIC_before = OICmean, mpi_before = first_peak_intensity),
    by = "nearest_ref_before"
  ) %>%
  left_join(
    bracketing_references %>%
      select(sample_order, analyzerTmean, TICmean, OICmean, first_peak_intensity) %>%
      rename(nearest_ref_after = sample_order, mean_temp_after = analyzerTmean, TIC_after = TICmean, OIC_after = OICmean, mpi_after = first_peak_intensity),
    by = "nearest_ref_after"
  ) %>%
  mutate(
    diff_temp_before = abs(analyzerTmean - mean_temp_before),
    diff_temp_after = abs(analyzerTmean - mean_temp_after),
    diff_TIC = ((TICmean-TIC_before)+(TICmean-TIC_after))/2,
    ratio_TIC = TICmean/((TIC_before+TIC_after)/2),
    ratio_OIC = OICmean/((OIC_before+OIC_after)/2),
    ratio_mpi = first_peak_intensity/((mpi_before + mpi_after)/2)
  )

wM0_analyses <- wM0_analyses %>%
  left_join(
    bracketing_references %>% 
      select(sample_order, R34S, R33S, R18O, R17O) %>%
      rename(nearest_ref_before = sample_order, 
             R34S_before = R34S, R33S_before = R33S, 
             R18O_before = R18O, R17O_before = R17O),
    by = "nearest_ref_before"
  ) %>%
  left_join(
    bracketing_references %>%
      select(sample_order, R34S, R33S, R18O, R17O) %>%
      rename(nearest_ref_after = sample_order, 
             R34S_after = R34S, R33S_after = R33S, 
             R18O_after = R18O, R17O_after = R17O),
    by = "nearest_ref_after"
  ) %>%
  rowwise() %>%
  mutate(
    R34S_ref = compute_ref(R34S_before, R34S_after, diff_temp_before, diff_temp_after),
    R33S_ref = compute_ref(R33S_before, R33S_after, diff_temp_before, diff_temp_after),
    R18O_ref = compute_ref(R18O_before, R18O_after, diff_temp_before, diff_temp_after),
    R17O_ref = compute_ref(R17O_before, R17O_after, diff_temp_before, diff_temp_after)
  ) %>%
  ungroup() %>%
  select(-R34S_before, -R34S_after, -R33S_before, -R33S_after, 
         -R18O_before, -R18O_after, -R17O_before, -R17O_after)

ratio_cols <- c("R34S", "R33S", "R18O", "R17O")
ref_ratio_cols <- c("R34S_ref", "R33S_ref", "R18O_ref", "R17O_ref")
wM0_deltas <- (wM0_analyses[, ratio_cols] / wM0_analyses[, ref_ratio_cols] - 1)*1000
colnames(wM0_deltas) <- sub("^R", "d", colnames(wM0_deltas))
colnames(wM0_deltas) <- sub("S$", "S32S", colnames(wM0_deltas))
colnames(wM0_deltas) <- sub("O$", "O16O", colnames(wM0_deltas))
# delta column names are now d34S32S, d33S32S, d18O16O, d17O16O
wM0_analyses <- cbind(wM0_analyses, wM0_deltas)

```

```{r noM0-bracketing, include=FALSE, echo=FALSE}
if (noM0==TRUE){
  noM0_bracketing_references <- subset(noM0_ruby_data_summary, sample_name == BRACKETING_REFERENCE)
  noM0_analyses <- subset(noM0_ruby_data_summary, sample_name != BRACKETING_REFERENCE)

  noM0_analyses <- noM0_analyses %>%
    rowwise() %>%
    mutate(
      nearest_ref_before = find_nearest(sample_order, bracketing_references$sample_order)[1],
      nearest_ref_after = find_nearest(sample_order, bracketing_references$sample_order)[2]
    ) %>%
    ungroup()

  noM0_analyses <- noM0_analyses %>%
    left_join(
      noM0_bracketing_references %>%
        select(sample_order, analyzerTmean, TICmean, OICmean, first_peak_intensity) %>%
        rename(nearest_ref_before = sample_order, mean_temp_before = analyzerTmean, TIC_before = TICmean, OIC_before = OICmean, mpi_before = first_peak_intensity),
      by = "nearest_ref_before"
    ) %>%
    left_join(
      noM0_bracketing_references %>%
        select(sample_order, analyzerTmean, TICmean, OICmean, first_peak_intensity) %>%
        rename(nearest_ref_after = sample_order, mean_temp_after = analyzerTmean, TIC_after = TICmean, OIC_after = OICmean, mpi_after = first_peak_intensity),
      by = "nearest_ref_after"
    ) %>%
    mutate(
      diff_temp_before = abs(analyzerTmean - mean_temp_before),
      diff_temp_after = abs(analyzerTmean - mean_temp_after),
      diff_TIC = ((TICmean-TIC_before)+(TICmean-TIC_after))/2,
      ratio_TIC = TICmean/((TIC_before+TIC_after)/2),
      ratio_OIC = OICmean/((OIC_before+OIC_after)/2),
      ratio_mpi = first_peak_intensity/((mpi_before + mpi_after)/2)
    )

  noM0_analyses <- noM0_analyses %>%
    left_join(
      noM0_bracketing_references %>% 
        select(sample_order, R33S, R18O, R17O) %>%
        rename(nearest_ref_before = sample_order, 
               R33S_before = R33S, 
               R18O_before = R18O, R17O_before = R17O),
      by = "nearest_ref_before"
    ) %>%
    left_join(
      noM0_bracketing_references %>%
        select(sample_order, R33S, R18O, R17O) %>%
        rename(nearest_ref_after = sample_order, 
               R33S_after = R33S, 
               R18O_after = R18O, R17O_after = R17O),
      by = "nearest_ref_after"
    ) %>%
    rowwise() %>%
    mutate(
      R33S_ref = compute_ref(R33S_before, R33S_after, diff_temp_before, diff_temp_after),
      R18O_ref = compute_ref(R18O_before, R18O_after, diff_temp_before, diff_temp_after),
      R17O_ref = compute_ref(R17O_before, R17O_after, diff_temp_before, diff_temp_after)
    ) %>%
    ungroup() %>%
    select(-R33S_before, -R33S_after, 
           -R18O_before, -R18O_after, -R17O_before, -R17O_after)

  noM0_ratio_cols <- c("R33S", "R18O", "R17O")
  noM0_ref_ratio_cols <- c("R33S_ref", "R18O_ref", "R17O_ref")
  noM0_deltas <- (noM0_analyses[, noM0_ratio_cols] / noM0_analyses[, noM0_ref_ratio_cols] - 1)*1000
  colnames(noM0_deltas) <- sub("^R", "d", colnames(noM0_deltas))
  colnames(noM0_deltas) <- sub("S$", "S34S", colnames(noM0_deltas))
  colnames(noM0_deltas) <- sub("O$", "O34S", colnames(noM0_deltas))
  # delta column names are now d33S34S, d18O34S, d17O34S
  noM0_analyses <- cbind(noM0_analyses, noM0_deltas)
}
```
<details><summary class="expandable_subtitles">Bracketing References - wM0</summary>

```{r visualize-bracketing-references-wM0, echo=FALSE, warning=FALSE, fig.width=10, fig.height=6}
Fig__R34S_vs_order <- ggplot() +
  geom_point(data = bracketing_references,
             mapping = aes(x=sample_order, y=R34S, shape=sample_name, fill=sample_name), size = 6) +
  geom_label_order(bracketing_references, aes(x = sample_order, y = R34S, label = sample_order)) +
  geom_point(data = wM0_analyses,
             mapping = aes(x=sample_order, y=R34S, shape=sample_name, fill=sample_name), size=6) +
  geom_label_order(wM0_analyses, aes(x = sample_order, y = R34S, label = sample_order)) +
  scale_color_manual(values=color_values) +
  scale_shape_manual(values=shape_values) +
  scale_fill_manual(values=color_values) +
  labs(title = "R34S vs sample order", x = "Sample order", y = "R34S")
print(Fig__R34S_vs_order)

Fig__R34Sref_vs_order <- ggplot() +
  geom_point(data = bracketing_references,
             mapping = aes(x = sample_order, y = R34S, shape=sample_name, fill=sample_name), size=6) +
  geom_label_order(bracketing_references, aes(x = sample_order, y = R34S, label = sample_order)) +
  geom_point(data = wM0_analyses, 
             mapping = aes(x = sample_order, y = R34S_ref, shape=sample_name, fill=sample_name), size=6) +
  geom_label_order(wM0_analyses, aes(x = sample_order, y = R34S_ref, label = sample_order)) +
  scale_color_manual(values=color_values) +
  scale_shape_manual(values=shape_values) +
  scale_fill_manual(values=color_values) +
  labs(
    title = paste0("Bracketing references R34S vs sample order."),
    x = "Sample order",
    y = "Bracketing reference R34S")
print(Fig__R34Sref_vs_order)

Fig__R34Sref_vs_AnalyzerT <- ggplot() +
  geom_point(data = wM0_analyses, 
             mapping = aes(x = analyzerTmean, y = R34S_ref, shape=sample_name, fill=sample_name), size=6) +
  geom_label_order(wM0_analyses, aes(x = analyzerTmean, y = R34S_ref, label = sample_order)) +
  scale_color_manual(values=color_values) +
  scale_shape_manual(values=shape_values) +
  scale_fill_manual(values=color_values) +
  labs(title = paste0("R34S_ref vs Analyzer temperature"),
       x = "Mean Analyzer Temp (*C)",
       y = "Bracketing Reference R34S")
print(Fig__R34Sref_vs_AnalyzerT)
```
</details>

```{r visualize-bracketing-references-noM0, results='asis', comment=NA, echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
if (noM0==TRUE){
  cat('<details><summary class="expandable_subtitles">Bracketing References - noM0</summary>\n')
    Fig__R33S34S_vs_order__noM0 <- ggplot() +
    geom_point(data = noM0_bracketing_references,
               mapping = aes(x=sample_order, y=R33S, shape=sample_name, fill=sample_name), size = 6) +
    geom_label_order(noM0_bracketing_references, aes(x = sample_order, y = R33S, label = sample_order)) +
    geom_point(data = noM0_analyses,
               mapping = aes(x=sample_order, y=R33S, shape=sample_name, fill=sample_name), size=6) +
    geom_label_order(noM0_analyses, aes(x = sample_order, y = R33S, label = sample_order)) +
    scale_color_manual(values=color_values) +
    scale_shape_manual(values=shape_values) +
    scale_fill_manual(values=color_values) +
    labs(title = "noM0 R33S34S vs sample order", x = "Sample order", y = "R33S34S")
  f1 <- file.path("figures","Fig__R33S34S_vs_order__noM0.png")
  ggsave(f1, Fig__R33S34S_vs_order__noM0, width = 10, height = 6, dpi = 150)

  Fig__R33S34Sref_vs_order__noM0 <- ggplot() +
    geom_point(data = noM0_bracketing_references,
               mapping = aes(x = sample_order, y = R33S, shape=sample_name, fill=sample_name), size=6) +
    geom_label_order(noM0_bracketing_references, aes(x = sample_order, y = R33S, label = sample_order)) +
    geom_point(data = noM0_analyses, 
               mapping = aes(x = sample_order, y = R33S_ref, shape=sample_name, fill=sample_name), size=6) +
    geom_label_order(noM0_analyses, aes(x = sample_order, y = R33S_ref, label = sample_order)) +
    scale_color_manual(values=color_values) +
    scale_shape_manual(values=shape_values) +
    scale_fill_manual(values=color_values) +
    labs(
      title = "noM0 Bracketing references R33S34S vs sample order.",
      x = "Sample order",
      y = "Bracketing reference R33S34S")
  f2 <- file.path("figures","Fig__R33S34Sref_vs_order__noM0.png")
  ggsave(f2, Fig__R33S34Sref_vs_order__noM0, width = 10, height = 6, dpi = 150)

  Fig__R33S34Sref_vs_AnalyzerT__noM0 <- ggplot() +
    geom_point(data = noM0_analyses, 
               mapping = aes(x = analyzerTmean, y = R33S_ref, shape=sample_name, fill=sample_name), size=6) +
    geom_label_order(noM0_analyses, aes(x = analyzerTmean, y = R33S_ref, label = sample_order)) +
    scale_color_manual(values=color_values) +
    scale_shape_manual(values=shape_values) +
    scale_fill_manual(values=color_values) +
    labs(title = paste0("noM0 R33S34S_ref vs Analyzer temperature"),
         x = "Mean Analyzer Temp (*C)",
         y = "Bracketing Reference R33S34S")
  f3 <- file.path("figures","Fig__R33S34Sref_vs_AnalyzerT__noM0.png")
  ggsave(f3, Fig__R33S34Sref_vs_AnalyzerT__noM0, width = 10, height = 6, dpi = 150)

  for (f in c(f1, f2, f3)) {
    cat(sprintf('<p><img src="%s" style="max-width: 100%%; height: auto;"></p>\n', f))
  }
  cat('</details>\n\n')
}
```

<details><summary class="expandable_subtitles">Raw Data Summary - wM0</summary>

```{r summarize-wM0-replicates, echo=FALSE, warning=FALSE}
wM0_run_summary <- wM0_analyses %>%
  group_by(sample_name) %>%
  summarise(
    n = sum(!is.na(d34S32S)),
    d34S32S_mean_val = mean(d34S32S, na.rm=TRUE),
    d34S32S_sd_val = sd(d34S32S, na.rm=TRUE),
    d33S32S_mean_val = mean(d33S32S, na.rm=TRUE),
    d33S32S_sd_val = sd(d33S32S, na.rm=TRUE),        
    d18O16O_mean_val = mean(d18O16O, na.rm=TRUE),
    d18O16O_sd_val = sd(d18O16O, na.rm=TRUE),
    d17O16O_mean_val = mean(d17O16O, na.rm=TRUE),
    d17O16O_sd_val = sd(d17O16O, na.rm=TRUE),
    mean_tic_val = mean(TICmean, na.rm=TRUE),
    sd_tic_val = sd(TICmean, na.rm=TRUE),
    mean_tic_diff = mean(diff_TIC, na.rm=TRUE),
    sd_tic_diff = sd(diff_TIC, na.rm=TRUE),
    mean_tic_ratio = mean(ratio_TIC, na.rm=TRUE),
    sd_tic_ratio = sd(ratio_TIC, na.rm=TRUE),
    mean_oic_ratio = mean(ratio_OIC, na.rm=TRUE),
    sd_oic_ratio = sd(ratio_OIC, na.rm=TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    d34S32S_mean = round(d34S32S_mean_val, 1),
    d34S32S_sd = round(d34S32S_sd_val, 2),
    d33S32S_mean = round(d33S32S_mean_val, 1),
    d33S32S_sd = round(d33S32S_sd_val, 2),
    d18O16O_mean = round(d18O16O_mean_val, 2),
    d18O16O_sd = round(d18O16O_sd_val, 2),
    d17O16O_mean = round(d17O16O_mean_val, 2),
    d17O16O_sd = round(d17O16O_sd_val, 2),
    TICmean = formatC(mean_tic_val, format = "e", digits = 2),
    TICsd = formatC(sd_tic_val, format = "e", digits = 2),
    TICdiff = formatC(mean_tic_diff, format = "e", digits = 2),
    TICdiffsd = formatC(sd_tic_diff, format = "e", digits = 2),
    TICratio = formatC(mean_tic_ratio, format = "e", digits = 2),
    TICratiosd = formatC(sd_tic_ratio, format = "e", digits = 2),
    run_name = run_name,
    run_date = substr(run_name, 1, 6),
    concentration = extract_conc(sample_name)   # ← add here
  ) %>%
  select(sample_name, n,
         TICmean, TICsd, TICdiff, TICdiffsd, TICratio, TICratiosd,
         d34S32S_mean, d34S32S_sd, d33S32S_mean, d33S32S_sd,
         d18O16O_mean, d18O16O_sd, d17O16O_mean, d17O16O_sd, 
         run_name, run_date, concentration)

scale_compression <- round(100 * (1 - (wM0_run_summary$d34S32S_mean[wM0_run_summary$sample_name=='S_MIF_2']-wM0_run_summary$d34S32S_mean[wM0_run_summary$sample_name=='SodSul_8']) / 30.9), 0)

# -------------------- Raw data summary table --------------------
run_summary_table_col_names <- c("Sample<br>Name", "n", "TIC<br>Mean", "TIC<br>SD", "TICdiff","TICdiffsd", "TICratio", "TICratiosd",
               "&#948;34S32S<br>Mean<br>(&#8240;)", "&#948;34S32S<br>SD",
               "&#948;18O16O<br>Mean<br>(&#8240;)", "&#948;18O16O<br>SD")
run_summary_display_columns <- c("sample_name", "n", "TICmean", "TICsd","TICdiff","TICdiffsd","TICratio","TICratiosd",
                                     "d34S32S_mean", "d34S32S_sd",
                                     "d18O16O_mean", "d18O16O_sd")

caption_text <- paste("Summary of measured &#948;34S32S and &#948;18O16O versus the bracketing standard. Scale compression based on d34S32S of S-MIF-2 and SodSul-8 = ", scale_compression, " %.")

knitr::kable(wM0_run_summary[, run_summary_display_columns], format = "html", caption = caption_text, 
             align = "c", col.names = run_summary_table_col_names, escape = FALSE) %>%
  column_spec(1, bold = TRUE)  # Makes the first column bold
```
</details>

```{r summarize-noM0-replicates, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
if (noM0 == TRUE) {

  cat('<details><summary class="expandable_subtitles">Raw Data Summary - noM0</summary>\n')

  noM0_run_summary <- noM0_analyses %>%
    dplyr::group_by(sample_name) %>%
    dplyr::summarise(
      n = sum(!is.na(d33S34S)),
      d33S34S_mean_val = mean(d33S34S, na.rm=TRUE),
      d33S34S_sd_val = sd(d33S34S, na.rm=TRUE),
      d18O34S_mean_val = mean(d18O34S, na.rm=TRUE),
      d18O34S_sd_val = sd(d18O34S, na.rm=TRUE),
      d17O34S_mean_val = mean(d17O34S, na.rm=TRUE),
      d17O34S_sd_val = sd(d17O34S, na.rm=TRUE),
      mean_tic_val = mean(TICmean, na.rm=TRUE),
      sd_tic_val = sd(TICmean, na.rm=TRUE),
      mean_tic_diff = mean(diff_TIC, na.rm=TRUE),
      sd_tic_diff = sd(diff_TIC, na.rm=TRUE),
      mean_tic_ratio = mean(ratio_TIC, na.rm=TRUE),
      sd_tic_ratio = sd(ratio_TIC, na.rm=TRUE),
      mean_oic_ratio = mean(ratio_OIC, na.rm=TRUE),
      sd_oic_ratio = sd(ratio_OIC, na.rm=TRUE),
      .groups = "drop"
    ) %>%
    dplyr::mutate(
      d33S34S_mean = round(d33S34S_mean_val, 1),
      d33S34S_sd   = round(d33S34S_sd_val, 2),
      d18O34S_mean = round(d18O34S_mean_val, 2),
      d18O34S_sd   = round(d18O34S_sd_val, 2),
      d17O34S_mean = round(d17O34S_mean_val, 2),
      d17O34S_sd   = round(d17O34S_sd_val, 2),
      TICmean    = formatC(mean_tic_val, format = "e", digits = 2),
      TICsd      = formatC(sd_tic_val, format = "e", digits = 2),
      TICdiff    = formatC(mean_tic_diff, format = "e", digits = 2),
      TICdiffsd  = formatC(sd_tic_diff, format = "e", digits = 2),
      TICratio   = formatC(mean_tic_ratio, format = "e", digits = 2),
      TICratiosd = formatC(sd_tic_ratio, format = "e", digits = 2),
      run_name = run_name,
      run_date = substr(run_name, 1, 6),
      concentration = extract_conc(sample_name)
    )

  noM0_run_summary_table_col_names <- c(
    "Sample<br>Name", "n",
    "TIC<br>Mean", "TIC<br>SD",
    "TICdiff", "TICdiffsd",
    "TICratio", "TICratiosd",
    "&#948;18O34S<br>Mean<br>(&#8240;)", "&#948;18O34S<br>SD"
  )

  noM0_run_summary_display_columns <- c(
    "sample_name", "n",
    "TICmean", "TICsd",
    "TICdiff", "TICdiffsd",
    "TICratio", "TICratiosd",
    "d18O34S_mean", "d18O34S_sd"
  )

  noM0_caption_text <- "Summary of measured &#948;18O34S, versus the bracketing standard."

  # Build HTML table as a string and emit it
  tbl_html <- knitr::kable(
    noM0_run_summary[, noM0_run_summary_display_columns],
    format   = "html",
    caption  = noM0_caption_text,
    align    = "c",
    col.names = noM0_run_summary_table_col_names,
    escape   = FALSE
  ) %>%
    kableExtra::kable_styling(full_width = FALSE) %>%
    kableExtra::column_spec(1, bold = TRUE)

  cat(tbl_html)

  cat('\n</details>\n\n')
}
```


```{r combine-wM0-noM0--create-run-summary, echo=FALSE}

if (noM0==FALSE){
  run_summary <- wM0_run_summary
} else {
  run_summary <- full_join(
    wM0_run_summary,
    noM0_run_summary,
    by = "sample_name",
    suffix = c("_wM0", "_noM0")
  )
}

if (noM0==FALSE){
  run_summary <- run_summary %>%
        mutate(d34S = d34S32S_mean,
               d33S = d33S32S_mean,
               d18O = d18O16O_mean,
               d17O = d17O16O_mean)
} else {
  run_summary <- run_summary %>%
        mutate(d34S = d34S32S_mean,
               d33S = ((d33S34S_mean/1000+1)*(d34S32S_mean/1000+1)-1)*1000,
               d18O = ((d18O34S_mean/1000+1)*(d34S32S_mean/1000+1)-1)*1000,
               d17O = ((d17O34S_mean/1000+1)*(d34S32S_mean/1000+1)-1)*1000)
}
```


```{r Reference-Material-Data-Frames, echo=FALSE}
# -------------------- CREATE REFERENCE MATERIAL DATA FRAMES FOR CALIBRATION --------------------

get_RM_calibration_values <- function(standards, delta, wM0_run_summary, ref_mat) {
  # Helper to get aliases for each RM key
  get_RM_names <- function(RM_key) {
    purrr::pluck(ref_mat, "sulfates", RM_key, "names", .default = character(0))
  }
  # Helper to get true/reference value
  get_RM_delta <- function(RM_key) {
    purrr::pluck(ref_mat, "sulfates", RM_key, delta, .default = NA_real_)
  }
  # Helper to get measured mean from wM0_run_summary
  get_measured_mean <- function(aliases) {
    if (!delta %in% names(run_summary)) return(NA_real_)
    mean(run_summary[[delta]][run_summary$sample_name %in% aliases], na.rm = TRUE)
  }
  
  tibble(name = standards) %>%
    mutate(
      ref_names = purrr::map(name, get_RM_names),
      meas_vs_M0 = purrr::map_dbl(ref_names, get_measured_mean),
      accepted  = purrr::map_dbl(name, get_RM_delta)
    ) %>%
    select(name, meas_vs_M0, accepted)
}


RM_17O <- get_RM_calibration_values(d17O_CALIBRATION_STANDARDS, "d17O", run_summary, ref_mat) %>% dplyr::rename(VSMOW = accepted)
RM_18O <- get_RM_calibration_values(d18O_CALIBRATION_STANDARDS, "d18O", run_summary, ref_mat) %>% dplyr::rename(VSMOW = accepted)
RM_33S <- get_RM_calibration_values(d33S_CALIBRATION_STANDARDS, "d33S", run_summary, ref_mat) %>% dplyr::rename(VCDT = accepted)
RM_34S <- get_RM_calibration_values(d34S_CALIBRATION_STANDARDS, "d34S", run_summary, ref_mat) %>% dplyr::rename(VCDT = accepted)
```


```{r Calibration-precheck, echo=FALSE, results='asis'}


calibration_ok <- TRUE

rm_check <- function(RM_dataframe) {
  # count usable points for lm()
  ok <- is.finite(RM_dataframe$meas_vs_M0) & is.finite(RM_dataframe[[3]])
  usable <- sum(ok, na.rm = TRUE)

  # Identify which standards are missing measured values
  missing_meas <- RM_dataframe$name[!is.finite(RM_dataframe$meas_vs_M0)]

  list(usable = usable, missing_meas = missing_meas)
}

# check each RM table (adjust min_points if you allow 2-point cal)
c34 <- rm_check(RM_34S)
c33 <- rm_check(RM_33S)
c18 <- rm_check(RM_18O)
c17 <- rm_check(RM_17O)

# Decide whether calibration can proceed
if (c34$usable < 2 || c33$usable < 2 || c18$usable < 2 || c17$usable < 2) {
  calibration_ok <- FALSE

  cat('
<div style="border:2px solid #b30000; padding:12px; border-radius:8px; background:#fff3f3;">
  <h3 style="margin-top:0;">⚠️ Calibration halted: required standards not found in this run</h3>
  <p>
    One or more calibration tables has <b>zero usable measured values</b> (meas_vs_M0 is NA/NaN),
    usually because the expected standards were not included (or were named differently) in this run.
  </p>
  <p><b>Fix:</b> update the calibration standard lists in the script (e.g., <code>d34S_CALIBRATION_STANDARDS</code>, etc.)
     to match the standards present in <code>run_summary$sample_name</code>, then re-render.</p>
  <ul>
')

  show_missing <- function(label, missing_vec) {
    if (length(missing_vec) > 0) {
      cat("<li><b>", label, " missing measured values for:</b> ",
          paste(missing_vec, collapse = ", "), "</li>", sep="")
    }
  }

  show_missing("d34S", c34$missing_meas)
  show_missing("d33S", c33$missing_meas)
  show_missing("d18O", c18$missing_meas)
  show_missing("d17O", c17$missing_meas)

  cat('
  </ul>
</div>
')

  if (calibration_ok){
    cat('<details><summary class="expandable_subtitles">Calibration to VCDT and VSMOW</summary>')
  } else {
    cat('<details><summary>Calibration to VCDT and VSMOW</summary>')
  }

}
```




```{r Calibrate-to-VCDT-VSMOW, echo=FALSE}
if (calibration_ok){
  # -------------------- CALIBRATE d34S to VCDT and d18O to VSMOW --------------------
  # Correct to VCDT by doing a three-point calibration, which is a linear regression of the three accepted values relative to their measured ratios
  # NOTE: Jongebloed et al. (2023a GRL; 2023b, ERL) used a 4-point calibration. This was made possible by aggregating data over many Shrek runs. If the orbitrap uncalibrated deltas change day-to-day, this might not be possible

  check_lm_data <- function(df, y, x, name) {
    if (!is.data.frame(df)) stop(name, " is not a data.frame/tibble")
    if (!all(c(y, x) %in% names(df))) stop(name, " missing columns: ", y, ", ", x)

    ok <- stats::complete.cases(df[, c(y, x)])
    message(name, ": nrow=", nrow(df),
            "  usable=", sum(ok),
            "  yNA=", sum(is.na(df[[y]])),
            "  xNA=", sum(is.na(df[[x]])),
            "  yClass=", paste(class(df[[y]]), collapse=","),
            "  xClass=", paste(class(df[[x]]), collapse=","))
    if (sum(ok) == 0) stop(name, " has 0 usable (non-NA) rows for lm(", y, " ~ ", x, ")")
  }

  check_lm_data(RM_34S, "VCDT",  "meas_vs_M0", "RM_34S")
  check_lm_data(RM_33S, "VCDT",  "meas_vs_M0", "RM_33S")
  check_lm_data(RM_18O, "VSMOW", "meas_vs_M0", "RM_18O")
  check_lm_data(RM_17O, "VSMOW", "meas_vs_M0", "RM_17O")

  model_34S <- lm(VCDT ~ meas_vs_M0, data = RM_34S)
  slope_34S <- coef(model_34S)[2]
  intercept_34S <- coef(model_34S)[1]
  run_summary$d34S_VCDT <- slope_34S*run_summary$d34S + intercept_34S

  model_33S <- lm(VCDT ~ meas_vs_M0, data = RM_33S)
  slope_33S <- coef(model_33S)[2]
  intercept_33S <- coef(model_33S)[1]
  run_summary$d33S_VCDT <- slope_33S*run_summary$d33S + intercept_33S

  model_18O <- lm(VSMOW ~ meas_vs_M0, data = RM_18O)
  slope_18O <- coef(model_18O)[2]
  intercept_18O <- coef(model_18O)[1]
  run_summary$d18O_VSMOW <- slope_18O*run_summary$d18O + intercept_18O

  model_17O <- lm(VSMOW ~ meas_vs_M0, data = RM_17O)
  slope_17O <- coef(model_17O)[2]
  intercept_17O <- coef(model_17O)[1]
  run_summary$d17O_VSMOW <- slope_17O*run_summary$d17O + intercept_17O

  run_summary$D17O_VSMOW <- run_summary$d17O_VSMOW - 0.52 * run_summary$d18O_VSMOW

  aliases_table <- tibble(
    key = sodium_sulfate_keys,
    alias = map(key, ~ pluck(ref_mat, "sulfates", .x, "names", .default = character(0))),
    d34Sacc = map_dbl(key, ~ pluck(ref_mat, "sulfates", .x, "d34S", .default = NA_real_)),
    d33Sacc = map_dbl(key, ~ pluck(ref_mat, "sulfates", .x, "d33S", .default = NA_real_)),
    d18Oacc = map_dbl(key, ~ pluck(ref_mat, "sulfates", .x, "d18O", .default = NA_real_)),
    d17Oacc = map_dbl(key, ~ pluck(ref_mat, "sulfates", .x, "d17O", .default = NA_real_))
  ) %>%
    unnest_longer(alias)

  run_summary <- run_summary %>%
    left_join(
      aliases_table %>% select(alias, d34Sacc, d33Sacc, d18Oacc, d17Oacc),
      by = c("sample_name" = "alias")
    )

  # go back and calibrate individual analyses so we can estimate errors
  wM0_analyses$d33S_VCDT <- slope_33S*wM0_analyses$d33S32S+intercept_33S
  wM0_analyses$d34S_VCDT <- slope_34S*wM0_analyses$d34S32S+intercept_34S
  wM0_analyses$d17O_VSMOW <- slope_17O*wM0_analyses$d17O16O+intercept_17O
  wM0_analyses$d18O_VSMOW <- slope_18O*wM0_analyses$d18O16O+intercept_18O

  run_summary_errors <- wM0_analyses %>%
    group_by(sample_name) %>%
    summarise(
      n = sum(!is.na(d34S_VCDT)),
      d33S_sd_val = sd(d33S_VCDT, na.rm=TRUE),
      d33S_VCDT_95CI = 1.96 * d33S_sd_val / sqrt(n),
      d34S_sd_val = sd(d34S_VCDT, na.rm=TRUE),
      d34S_VCDT_95CI = 1.96 * d34S_sd_val / sqrt(n),
      d17O_sd_val = sd(d17O_VSMOW, na.rm=TRUE),
      d17O_VSMOW_95CI = 1.96 * d17O_sd_val / sqrt(n),
      d18O_sd_val = sd(d18O_VSMOW, na.rm=TRUE),
      d18O_VSMOW_95CI = 1.96 * d18O_sd_val / sqrt(n),
      .groups = "drop"
  )

  # add newly calculated errors to summary data frame
  run_summary <- run_summary %>%
    left_join(
      run_summary_errors %>%
        select(sample_name, d33S_VCDT_95CI, d34S_VCDT_95CI, d17O_VSMOW_95CI, d18O_VSMOW_95CI),
      by = "sample_name"
    )
}
```

```{r export-analyses-data, echo=FALSE, include=FALSE}
write.csv(wM0_analyses, paste0(DATA_DIRECTORY,"/", run_name,"/",run_name,"__analyses_export.csv"), row.names = FALSE)
```

```{r export-run-summary, echo=FALSE, include=FALSE}
run_summary[] <- lapply(run_summary, function(x) {
  tmp <- suppressWarnings(as.numeric(x))
  if (sum(!is.na(tmp)) >= sum(!is.na(x)) / 2) tmp else x
})
write.csv(run_summary, paste0(DATA_DIRECTORY,"/", run_name,"/",run_name,"__run_summary.csv"), row.names = FALSE)
```

```{r Samples-Summary-Table, echo=FALSE, message=FALSE, warning=FALSE}
if (calibration_ok){
  samples_summary <- run_summary %>%
    mutate(
      sample_name = sample_name,
      n = n_wM0,

      d34S_mean = round(d34S_VCDT, 1),
      d34S_bias = round(d34S_VCDT-d34Sacc, 1),
      d34S_95CI = round(d34S_VCDT_95CI, 2),

      d33S_mean = round(d33S_VCDT, 1),
      d33S_bias = round(d33S_VCDT-d33Sacc, 1),
      d33S_95CI = round(d33S_VCDT_95CI, 2),
          
      d18O_mean = round(d18O_VSMOW, 1),
      d18O_bias = round(d18O_VSMOW-d18Oacc, 1),
      d18O_95CI = round(d18O_VSMOW_95CI, 2),

      d17O_mean = round(d17O_VSMOW, 1),
      d17O_bias = round(d17O_VSMOW-d17Oacc, 1),
      d17O_95CI = round(d17O_VSMOW_95CI, 2),

      D17O_mean = round(D17O_VSMOW, 1)
    ) %>%
    
    select(sample_name, n, d34S_mean, d34S_95CI, d34S_bias, d18O_mean, d18O_95CI, d18O_bias, d33S_mean, d33S_95CI, d33S_bias, d17O_mean, d17O_95CI, d17O_bias, D17O_mean)

  samples_summary_table_col_names <- c("Sample<br>Name", "n",
                 "&#948;<sup>34</sup>S<br>Mean<br>VCDT<br>(&#8240;)",
                 "&#948;<sup>34</sup>S<br>95%<br>CI",
                 "&#948;<sup>34</sup>S<br>bias", 
                 "&#948;<sup>18</sup>O<br>Mean<br>VSMOW<br>(&#8240;)",
                 "&#948;<sup>18</sup>O<br>95%<br>CI",
                 "&#948;<sup>18</sup>O<br>bias",
                 "&#948;<sup>33</sup>S<br>Mean<br>VCDT<br>(&#8240;)",
                 "&#948;<sup>33</sup>S<br>95%<br>CI",
                 "&#948;<sup>33</sup>S<br>bias",
                 "&#948;<sup>17</sup>O<br>Mean<br>VSMOW<br>(&#8240;)",
                 "&#948;<sup>17</sup>O<br>95%<br>CI",
                 "&#948;<sup>17</sup>O<br>bias",
                 "&#916;<sup>17</sup>O<br>Mean<br>VSMOW<br>(&#8240;)")

  caption_text <- paste("Summary of calibrated &#948;<sup>34</sup>S, &#948;<sup>18</sup>O, &#948;<sup>33</sup>S, &#948;<sup>17</sup>O, and &#916;<sup>17</sup>O.")

  knitr::kable(samples_summary, format = "html", caption = caption_text, 
               align = "c", col.names = samples_summary_table_col_names, escape = FALSE) %>%
    column_spec(1, bold = TRUE)  # Makes the first column bold
}
```

</details>

<details><summary class="expandable_subtitles">Replicate Calibrated Data</summary>

These figures are intended to provide a sense of sample spread.

```{r replicate-assessment, echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
if (calibration_ok){
  # All sample names present in this run (with non-NA d34S_VCDT)
  sample_levels <- wM0_analyses %>%
    filter(!is.na(d34S_VCDT)) %>%
    arrange(sample_name, sample_order) %>%
    pull(sample_name) %>%
    unique()

  # Filter your main dataframe to remove NAs
  samples_df_noNA <- wM0_analyses %>%
    filter(!is.na(d34S_VCDT)) %>%
    mutate(
      sample_name = factor(sample_name, levels = sample_levels)
    )

  # Order and position samples
  samples_df_order <- samples_df_noNA %>%
    arrange(sample_name, sample_order) %>%
    mutate(
      x_pos = as.numeric(sample_name) +
        (sample_order - min(sample_order)) * 0.010
    )

  # Compute shading width from actual sample extents
  shading_extents <- samples_df_order %>%
    group_by(sample_name) %>%
    summarise(
      x_min = min(x_pos) - 0.05,
      x_max = max(x_pos) + 0.05,
      .groups = "drop"
    )

  # Prepare shading values from scratch
  shading_values <- tibble(sample_name = sample_levels) %>%
    mutate(
      shade_y = purrr::map_dbl(
        sample_name,
        ~ purrr::pluck(ref_mat, "sulfates", .x, "d34S", .default = NA_real_)
      )
    ) %>%
    left_join(shading_extents, by = "sample_name") %>%
    mutate(
      y_min = shade_y - 0.8,
      y_max = shade_y + 0.8
    ) %>%
    filter(!is.na(shade_y))


  Fig_delta34S_vs_order <- ggplot() + 
    geom_point(data = samples_df_order,
               aes(x = x_pos, y = d34S_VCDT,  shape=sample_name, fill=sample_name), size=6) +
    geom_label_order(samples_df_order, aes(x = x_pos, y = d34S_VCDT, label = sample_order)) +
    scale_color_manual(values=color_values) +
    scale_shape_manual(values=shape_values) +
    scale_fill_manual(values=color_values) +
    geom_rect(data = shading_values,
              aes(xmin = x_min, xmax = x_max, ymin = y_min, ymax = y_max),
              fill = "gray80", alpha = 0.5, inherit.aes = FALSE) +
    scale_x_continuous(breaks = NULL) +
    labs(x = "Sample Type", y = expression(delta^34*"S (VCDT)"), color = "Sample Name")
  print(Fig_delta34S_vs_order)


  run_summary_concentration <- run_summary[!is.na(run_summary$concentration_wM0), ]
  if (nrow(run_summary_concentration)>0){
    Fig_d34S_vs_TIC <- ggplot(run_summary_concentration) +
      geom_point(aes(x=TICmean, y=d34S_VCDT,  shape=sample_name, fill=sample_name), size=6) +
      scale_color_manual(values=color_values) +
      scale_shape_manual(values=shape_values) +
      scale_fill_manual(values=color_values) +
      geom_errorbar(aes(ymin = d34S_VCDT - d34S_VCDT_95CI,
                      ymax = d34S_VCDT + d34S_VCDT_95CI),
                  width = 0.2,
                  linewidth = 0.8) +
      geom_label_order(run_summary_concentration, aes(x = TICmean, y = d34S_VCDT, label = sample_order)) +
      labs(x = "TIC", y = expression(delta^34*"S (VCDT)"), color = "Sample Name")
    print(Fig_d34S_vs_TIC)


    Fig_d34S_vs_TICratio <- ggplot(run_summary_concentration) +
      geom_point(aes(x=TICratio, y=d34S_VCDT, color=sample_name), size = 5) +
      geom_errorbar(aes(ymin = d34S_VCDT - d34S_VCDT_95CI, ymax = d34S_VCDT + d34S_VCDT_95CI),
                        width = 0.2,
                        linewidth = 0.8) +
      geom_label_order(run_summary_concentration, aes(x = TICratio, y = d34S_VCDT, label = sample_order)) +
      labs(x = "TICratio", y = expression(delta^34*"S (VCDT)"), color = "Sample Name")
    print(Fig_d34S_vs_TICratio)


    Fig_d34S_vs_concentration <- ggplot(run_summary_concentration) + 
      geom_point(aes(x=concentration, y=d34S_VCDT, color=sample_name), size = 5) +
      geom_errorbar(aes(ymin = d34S_VCDT - d34S_VCDT_95CI, ymax = d34S_VCDT + d34S_VCDT_95CI),
                        width = 0.2,
                        linewidth = 0.8) +
      geom_label_order(run_summary_concentration, aes(x = concentration, y = d34S_VCDT, label = sample_order)) +
      labs(x = "Sample Concentration (uM)", y = expression(delta^34*"S (VCDT)"), color = "Sample Name")
    print(Fig_d34S_vs_concentration)


    Fig_tic_vs_concentration <- ggplot(run_summary_concentration) +
      geom_point(aes(x=concentration, y=TICmean, color=sample_name), size = 5) +
      geom_errorbar(aes(ymin = TICmean - TICsd, ymax = TICmean + TICsd),
                        width = 0.2,
                        linewidth = 0.8) +
      geom_label_order(run_summary_concentration, aes(x = concentration, y = TICmean, label = sample_order)) +
      labs(x = "Sample Concentration (uM)", y = "TIC", color = "Sample Name")
    print(Fig_tic_vs_concentration)

  } else {
    print('No concentration range analyses')
  }
  write.csv(wM0_analyses, file = paste0(run_name,"__raw_byInjection.csv"), row.names = FALSE)

  write.csv(bracketing_references, file = paste0(run_name,"__bracketing.csv"), row.names = FALSE)
}
```

```{r residual-figures, echo=FALSE, warning=FALSE, fig.width=10, fig.height=6}
if (calibration_ok){
  # Calculate the residual (departure from mean) for all replicated analyses and across all deltas.
  residuals <- wM0_analyses %>%
    group_by(sample_name) %>%
    mutate(across(c(d34S32S, d18O16O, d17O16O, d33S32S), ~ . - mean(. , na.rm = TRUE), .names = "{.col}_residual")) %>%
    ungroup()

  d34S32S_precision <- round(sd(residuals$d34S32S_residual, na.rm = TRUE) * 2, 2)
  d18O16O_precision <- round(sd(residuals$d18O16O_residual, na.rm = TRUE) * 2, 2)
  d34S32S_outlier <- round(sd(residuals$d34S32S_residual, na.rm = TRUE) * 3.3, 2)
  d18O16O_outlier <- round(sd(residuals$d18O16O_residual, na.rm = TRUE) * 3.3, 2)


  d34S32S_title <- paste0("d34S residual 2-sigma = ", d34S32S_precision, " permil; (yellow = 95%; red = 99.9%)")
  Fig_d34Sresidual_vs_order <- ggplot(residuals) + 
        geom_point(aes(x=sample_order, y=d34S32S_residual, shape=sample_name, fill=sample_name), size=6) +
        geom_hline(yintercept = d34S32S_precision,   linetype = "solid", color = "yellow",   linewidth = 0.5) +
        geom_hline(yintercept = -d34S32S_precision,   linetype = "solid", color = "yellow",   linewidth = 0.5) +
        geom_hline(yintercept = d34S32S_outlier,   linetype = "solid", color = "red",   linewidth = 0.5) +
        geom_hline(yintercept = -d34S32S_outlier,   linetype = "solid", color = "red",   linewidth = 0.5) +
        scale_color_manual(values=color_values) +
        scale_shape_manual(values=shape_values) +
        scale_fill_manual(values=color_values) +
        geom_label_order(residuals, aes(x = sample_order, y = d34S32S_residual, label = sample_order)) +
        labs(title = d34S32S_title, x = "Sample Order", y = "d34S residual (permil)", color = "Sample Name")
  print(Fig_d34Sresidual_vs_order)

  # Ensure sample_name is a factor
  residuals$sample_name <- factor(residuals$sample_name)

  # Compute mean ± SD for each sample
  sd_data <- residuals %>%
    group_by(sample_name) %>%
    summarise(
      mean_residual = mean(d34S32S_residual, na.rm = TRUE),
      sd_residual   = sd(d34S32S_residual, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(
      ymin = mean_residual - sd_residual*2,
      ymax = mean_residual + sd_residual*2
    )

  # Merge SD info into main data + flag outliers
  residuals_flagged <- residuals %>%
    left_join(sd_data, by = "sample_name") %>%
    mutate(
      outside_sd = d34S32S_residual < ymin | d34S32S_residual > ymax,
      label_font = ifelse(outside_sd, "bold", "plain")
    )

  Fig_d34Sresidual_vs_name <- ggplot() +
    
    # ---- SD shaded region ----
    geom_rect(
      data = sd_data,
      aes(
        xmin = as.numeric(sample_name) - 0.45,
        xmax = as.numeric(sample_name) + 0.45,
        ymin = ymin,
        ymax = ymax,
        fill = sample_name
      ),
      alpha = 0.25,
      show.legend = FALSE
    ) +
    
    # ---- Points ----
    geom_point(data = residuals_flagged,
               aes(x = sample_name, y = d34S32S_residual, shape=sample_name, fill=sample_name), size=6) +
    geom_hline(yintercept = d34S32S_precision,   linetype = "solid", color = "yellow",   linewidth = 0.5) +
    geom_hline(yintercept = -d34S32S_precision,   linetype = "solid", color = "yellow",   linewidth = 0.5) +
    geom_hline(yintercept = d34S32S_outlier,   linetype = "solid", color = "red",   linewidth = 0.5) +
    geom_hline(yintercept = -d34S32S_outlier,   linetype = "solid", color = "red",   linewidth = 0.5) +
    scale_color_manual(values=color_values) +
    scale_shape_manual(values=shape_values) +
    scale_fill_manual(values=color_values) +
    geom_label_order(residuals_flagged, aes(x = sample_name, y = d34S32S_residual, label = sample_order)) +

    labs(
      title = "2-Sigma range highlighted",
      x = "Sample Name",
      y = "d34S residual (permil)",
      color = "Sample Name"
    )
  print(Fig_d34Sresidual_vs_name)



  # Fig_d34Sresidual_vs_TIC <- ggplot() + 
  #       geom_point(data=residuals, mapping=aes(x=TICmean, y=d34S32S_residual, shape=sample_name, fill=sample_name), size=6) +
  #       scale_color_manual(values=color_values) +
  #       scale_shape_manual(values=shape_values) +
  #       scale_fill_manual(values=color_values) +
  #       geom_label_order(residuals, aes(x = TICmean, y = d34S32S_residual, label = sample_order)) +
  #       labs(title = d34S32S_title, x = "Mean TIC", y = "d34S residual (permil)", color = "Sample Name")
  # print(Fig_d34Sresidual_vs_TIC)



  d18O16O_title <- paste0("d18O residual 2-sigma = ", d18O16O_precision, " permil; (yellow = 95%; red = 99.9%)")
  Fig_d18Oresidual_vs_order <- ggplot() + 
        geom_point(data=residuals, mapping=aes(x=sample_order, y=d18O16O_residual, shape=sample_name, fill=sample_name), size=6) +
        geom_hline(yintercept = d18O16O_precision,   linetype = "solid", color = "yellow",   linewidth = 0.5) +
        geom_hline(yintercept = -d18O16O_precision,   linetype = "solid", color = "yellow",   linewidth = 0.5) +
        geom_hline(yintercept = d18O16O_outlier,   linetype = "solid", color = "red",   linewidth = 0.5) +
        geom_hline(yintercept = -d18O16O_outlier,   linetype = "solid", color = "red",   linewidth = 0.5) +
        scale_color_manual(values=color_values) +
        scale_shape_manual(values=shape_values) +
        scale_fill_manual(values=color_values) +
        geom_label_order(residuals, aes(x = sample_order, y = d18O16O_residual, label = sample_order)) +
        labs(title = d18O16O_title, x = "Sample Order", y = "d18O residual (permil)", color = "Sample Name")
  print(Fig_d18Oresidual_vs_order)

}
```

</details>

<details><summary class="expandable_subtitles">Reference Materials</summary>

```{r Reference-Material-Table, echo=FALSE}
# -------------------- CREATE REFERENCE MATERIAL TABLE OF ACCEPTED VALUES --------------------

reference_materials <- tibble(
  name = sodium_sulfate_keys,
  d34S = map_dbl(sodium_sulfate_keys, ~ pluck(ref_mat, "sulfates", .x, "d34S", .default = NA_real_)),
  d18O = map_dbl(sodium_sulfate_keys, ~ pluck(ref_mat, "sulfates", .x, "d18O", .default = NA_real_)),
  D17O = map_dbl(sodium_sulfate_keys, ~ pluck(ref_mat, "sulfates", .x, "D17O", .default = NA_real_)),
  d33S = map_dbl(sodium_sulfate_keys, ~ pluck(ref_mat, "sulfates", .x, "d33S", .default = NA_real_)),
  notes = map_chr(sodium_sulfate_keys, ~ pluck(ref_mat, "sulfates", .x, "notes", .default = NA_character_))
)

reference_materials_table_col_names <- c("Reference<br>Material",
                                         "&#948;<sup>34</sup>S<br>VCDT<br>(&#8240;)",
                                         "&#948;<sup>18</sup>O<br>VSMOW<br>(&#8240;)",
                                         "&#916;<sup>17</sup>O<br>VSMOW<br>(&#8240;)",
                                         "&#948;<sup>33</sup>S<br>VCDT<br>(&#8240;)",
                                         "Notes")

caption_text <- "Table of <strong>accepted values</strong> as taken from reference_materials.json."

knitr::kable(reference_materials, format = "html", caption = caption_text, 
             align = "c", col.names = reference_materials_table_col_names, escape = FALSE) %>%
  column_spec(1, bold = TRUE) %>%  # Makes the first column bold
  column_spec(6, 
    width = "300px", 
    extra_css = "font-size: 10px; word-break: break-word;"
  )
```

</details>

<details><summary class="expandable_subtitles">Acknowledgements</summary>
This package builds on the excellent ecosystem of open-source tools, especially:

- [`isoorbi`](https://github.com/isoorbi/isoorbi) – Orbitrap data processing foundations  
- [`dplyr`](https://dplyr.tidyverse.org/) – data manipulation  
- [`ggplot2`](https://ggplot2.tidyverse.org/) – visualization  
- [`jsonlite`](https://github.com/jeroen/jsonlite) – JSON handling  
</details>

<details><summary class="expandable_subtitles">Script Change Log</summary>

- 2024-09-16 => Saved from v240912_0918 as Becky's original filename (CalculateDeltas.R) for simplicity.
- 2024-10-14 => Tried to update in favor of flexible sample names and unknown sample names
- 2024-10-21 => Adding noM0 as option
- 2025-01-09 => this version has isoorbi.uw and run_name to show figure titles as the run name
- 2025-01-21 => found bug in plot_tic and plot_ratio functions, they were not working with noM0; other noM0 fixes
- 2025-01-22 => added .raw file time stamps
- 2025-01-28 => continued refining this code as an Rmarkdown file
- 2025-02-03 => initial adjustments for Ruby-only runs, which is basically commenting out lots of lines
- 2025-02-23 => had gone back to .R, now know how to run and troubleshoot in .Rmd, back to .Rmd, this one is a Ruby-only bracketing based script
- 2025-03-13 => added ruby sample peak start and end as measurements for each sample rather than fixed values
- 2025-05-01 => trying to resurrect noM0 after trying HCD fragmentation to SO3
- 2025-06-05 => trying to make reference material name recognition more versatile. 
- 2025-06-08 => this version worked for the wM0 and noM0 parts of 250529 and it also seems to calculate the bias correctly
- 2025-06-12 => table cleanup
- 2025-08-27 => created user-defined-peak definition and placed it at the top for easier access; cleaned up code; moved analyzer temperature plot and changed its data frame source so bracketing references are plotted; started adding Ursula's figures back in; 
- 2025-09-09 => moved more frequently changed items to top of script; added boolean for choosing ruby start and end
- 2025-09-30 => combining high-res-ivan.R with ruby.Rmd, and so far calling it ivanruby.Rmd. Here are some important notes regarding this combination:
  - ruby.Rmd used the sum method in isoorbi to calculate the ratios (orbi_summarize_results(ratio_method = "sum")). high-res-ivan.R uses dplyr summarize and mean, which, I think, should be identical to isoorbit arithmetic mean. This present code, uses the dplyr summarize mean method.
- 2025-10-21 => now using melvin
- 2025-11-13 => raw data support. NO MORE ISOX. Drew's TIC ratio math as of ivanruby.Rmd in run directory 251107. Jack's manuscript peak definition can be selected. Now need to test on a variety of runs to make sure I have raw data support truly working.
- 2025-11-18 => wM0_SAMPLES_TO_IGNORE works again, it was dead after moving to raw files; 
- 2025-11-20 => moved analyses export to csv up next to vial level export
- 2025-12-05 => fix bug in where csv files were being saved
- 2025-12-25 => moved to git and github, merged Drew's version, merged Andy's version, saved as sulfate.Rmd, added this comment to practice branching, merging, and all the git things
- 2025-12-27 => minor cleanup, standardized figures, removed old content
- 2025-12-30 => trying to make sulfate.Rmd handle both HSO4 and SO3; the first raw file is read in and the LowMass is used to decide if we measured HSO4 or SO3; added precision and outlier horizontal lines to residual figures 
- 2025-12-31 => removed isox relicts; trying for noM0 support again
- 2026-01-11 => mostly done with noM0 support; still need to work out error calculation
</details>

```{r, save-workspace, echo=FALSE, include=FALSE}
save.image(file = file.path(DATA_DIRECTORY, run_name,"workspace.RData"))
```
